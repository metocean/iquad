// Generated by CoffeeScript 1.9.2
var whakaruru;

whakaruru = require('whakaruru');
var cors = require('cors')

whakaruru(function() {
  var app, async, compression, dataset, datasets, express, filesize, fn, fs, heap, maxzoom, metadatadir, mutunga, name, path, quaddy, quadify, tasks, tiletolnglat, url;
  express = require('express');
  mutunga = require('http-mutunga');
  fs = require('fs');
  tiletolnglat = require('tiletolnglat');
  quadify = require('./quadify');
  async = require('odo-async');
  filesize = require('filesize');
  path = require('path');
  quaddy = require('quaddy');
  url = require('url');
  app = express();
  app.use(cors())
  app.use((function(_this) {
    return function(req, res, next) {
      var referrer, u;
      if (req.header('host') != null) {
        referrer = req.protocol + "://" + (req.header('host'));
        if (req.header('referer') != null) {
          u = url.parse(req.header('referer'));
          referrer = u.protocol + "//" + u.host;
        }
        res.header('Access-Control-Allow-Origin', referrer);
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type');
      }
      return next();
    };
  })(this));
  app.disable('x-powered-by');
  compression = require('compression');
  app.use(compression());
  app.enable('trust proxy');
  metadatadir = '/metadata/';
  datasets = fs.readFileSync(path.join(metadatadir, 'datasets.json'));
  datasets = JSON.parse(datasets);
  console.log("Loading " + (Object.keys(datasets).length) + " datasets from HD");
  heap = process.memoryUsage().heapUsed;
  tasks = [];
  maxzoom = 0;
  fn = function(name, dataset) {
    maxzoom = Math.max(maxzoom, dataset.zoom);
    return tasks.push(function(cb) {
      return fs.readFile(path.join(metadatadir, dataset.file), function(err, points) {
        points = JSON.parse(points);
        dataset.points = points;
        return cb();
      });
    });
  };
  for (name in datasets) {
    dataset = datasets[name];
    fn(name, dataset);
  }
  return async.parallel(tasks, function() {
    var quadtree, server;
    heap = process.memoryUsage().heapUsed - heap;
    console.log((filesize(heap)) + " for " + (Object.keys(datasets).length) + " raw datasets");
    quadtree = quaddy.preallocate(maxzoom);
    for (name in datasets) {
      dataset = datasets[name];
      console.log("Quadding " + name);
      quadify(quadtree, name, dataset.points, dataset.zoom);
    }
    heap = process.memoryUsage().heapUsed - heap;
    console.log((filesize(heap)) + " for " + (Object.keys(datasets).length) + " dataset quadtrees");
    app.get('/', function(req, res) {
      return res.send({
        datasets: Object.keys(datasets).map(function(name) {
          dataset = datasets[name];
          return {
            name: name,
            points: dataset.points.lon.length,
            zoom: dataset.zoom,
            url: "/" + name + "/{z}/{x}/{y}.json"
          };
        })
      });
    });
    app.get('/:dataset/:z/:x/:y.json', function(req, res) {
      var node, ref, x, y, z;
      name = req.params.dataset;
      if (datasets[name] == null) {
        res.status(404);
        res.send({
          message: name + " is not a valid dateset"
        });
        return;
      }
      dataset = datasets[name];
      x = parseInt(req.params.x);
      y = parseInt(req.params.y);
      z = parseInt(req.params.z);
      node = quadtree.get(x, y, z);
      if ((node != null) && (node[name] != null)) {
        node = node[name];
      }
      return res.send({
        type: 'FeatureCollection',
        features: [
          {
            id: 'count',
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: tiletolnglat(x + 0.5, y + 0.5, z)
            },
            properties: {
              count: (ref = node != null ? node.count : void 0) != null ? ref : 0,
              up: quaddy.up(x, y, z)
            }
          }, {
            id: 'points',
            type: 'Feature',
            geometry: {
              type: 'MultiPoint',
              coordinates: (node != null ? node.indexes : void 0) != null ? node.indexes.map(function(i) {
                return [parseFloat(dataset.points.lon[i].toFixed(4)), parseFloat(dataset.points.lat[i].toFixed(4))];
              }) : []
            }
          }
        ]
      });
    });
    return server = mutunga(app).listen(8081, function() {
      return process.on('SIGTERM', function() {
        console.log(process.pid + " Ōhākī");
        return server.close(function() {
          return process.exit(0);
        });
      });
    });
  });
});
